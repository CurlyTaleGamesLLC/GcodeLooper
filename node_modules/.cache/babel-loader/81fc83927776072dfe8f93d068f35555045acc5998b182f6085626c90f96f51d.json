{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nexport default {\n  data() {\n    return {\n      gcodeText: '',\n      thumbnailSrc: '',\n      fileName: '',\n      newFileName: '',\n      form: {\n        copies: 10,\n        ejectionSide: 'Front',\n        pushHeight: 20.0,\n        ejectionOffset: 40.0,\n        bedLength: null,\n        bedWidth: null\n      },\n      gcodeData: {\n        height: 0,\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0,\n        extrusionWidth: 0,\n        bounds: {\n          minX: 0,\n          maxX: 0,\n          minY: 0,\n          maxY: 0\n        },\n        printTimeSeconds: 0,\n        totalPrintTime: 0,\n        totalGramsOfFilament: 0,\n        totalCostOfFilament: 0\n      }\n    };\n  },\n  methods: {\n    browseFile() {\n      this.$refs.fileInput.click();\n    },\n    replaceFile() {\n      this.gcodeText = '';\n      this.thumbnailSrc = '';\n      this.fileName = '';\n      this.$refs.fileInput.click();\n    },\n    onFileChange(e) {\n      const files = e.target.files || e.dataTransfer.files;\n      if (!files.length) return;\n\n      // Check the file extension\n      if (files[0].name.split('.').pop().toLowerCase() !== 'gcode') {\n        alert('Invalid file type. Please upload a .gcode file.');\n        return;\n      }\n      this.fileName = files[0].name;\n      this.createFile(files[0]);\n    },\n    onDrop(e) {\n      // Get the dropped files\n      const files = e.dataTransfer.files;\n      if (!files.length) return;\n\n      // Check the file extension\n      if (files[0].name.split('.').pop().toLowerCase() !== 'gcode') {\n        alert('Invalid file type. Please upload a .gcode file.');\n        return;\n      }\n      this.onFileChange(e);\n    },\n    createFile(file) {\n      const reader = new FileReader();\n      reader.onload = e => {\n        this.gcodeText = e.target.result;\n        this.thumbnailSrc = this.extractLargestThumbnail(this.gcodeText);\n        this.gcodeData.extrusionWidth = this.parseExtrusionWidth(this.gcodeText);\n        this.gcodeData.height = this.parseZHeight(this.gcodeText);\n        this.gcodeData.printTimeSeconds = this.parseAndConvertTime(this.gcodeText);\n        this.gcodeData.bounds = this.findBounds(this.gcodeText);\n      };\n      reader.readAsText(file);\n    },\n    extractLargestThumbnail(gcode) {\n      console.log(\"Extracting Text\");\n      console.log(gcode);\n      const matches = gcode.match(/; thumbnail begin (\\d+)x(\\d+) (\\d+)([\\s\\S+]*?); thumbnail end/g);\n      if (!matches) return '';\n      let largestThumbnail = '';\n      let largestResolution = 0;\n      matches.forEach(match => {\n        console.log(match);\n        const resolutionMatch = match.match(/; thumbnail begin (\\d+)x(\\d+) (\\d+)/);\n        if (resolutionMatch) {\n          const width = parseInt(resolutionMatch[1], 10);\n          const height = parseInt(resolutionMatch[2], 10);\n          const resolution = width * height;\n          if (resolution > largestResolution) {\n            largestResolution = resolution;\n            // Extract the base64 thumbnail data\n            let base64String = match.replace(/^.*\\n|\\n|;\\s*/g, '');\n            base64String = base64String.replace(/=thumbnail end/g, '=');\n            largestThumbnail = 'data:image/png;base64, ' + base64String;\n          }\n        }\n      });\n      return largestThumbnail;\n    },\n    downloadFile() {\n      const blob = new Blob([this.gcodeText], {\n        type: 'text/plain'\n      });\n      const link = document.createElement('a');\n      link.href = URL.createObjectURL(blob);\n      link.download = this.createNewFilename(this.fileName, this.form.copies, this.gcodeData.printTimeSeconds) || 'downloaded.gcode'; // Use stored fileName for download\n      link.click();\n    },\n    parseZHeight(gcode) {\n      let highestZ = 0;\n      // Split the G-code text into lines\n      const lines = gcode.split('\\n');\n      // Iterate over each line\n      lines.forEach(line => {\n        // Check if the line starts with ;Z:\n        if (line.startsWith(';Z:')) {\n          // Parse the Z height value from the line\n          const zHeight = parseFloat(line.split(';Z:')[1]);\n          // Update highestZ if this zHeight is greater than the current highestZ\n          if (zHeight > highestZ) {\n            highestZ = zHeight;\n          }\n        }\n      });\n      return highestZ;\n    },\n    parseAndConvertTime(gcode) {\n      // This regex captures optional days, hours, minutes, and seconds parts\n      const timeMatch = gcode.match(/estimated printing time.*?(?:(\\d+)d )?(?:(\\d+)h )?(\\d+)m (\\d+)s/);\n\n      // Check if the match is found and has the expected groups\n      if (timeMatch) {\n        // Convert the time to seconds\n        const days = parseInt(timeMatch[1] || 0, 10); // Default to 0 if days part is not present\n        const hours = parseInt(timeMatch[2] || 0, 10); // Default to 0 if hours part is not present\n        const minutes = parseInt(timeMatch[3], 10);\n        const seconds = parseInt(timeMatch[4], 10);\n        const totalSeconds = days * 86400 + hours * 3600 + minutes * 60 + seconds; // 1 day = 86400 seconds\n\n        // Return the total time in seconds\n        return totalSeconds;\n      } else {\n        // Return null or some default value if the time cannot be parsed\n        console.warn('Could not parse estimated printing time from G-code');\n        return null;\n      }\n    },\n    parseGramsOfFilament(gcode) {\n      // This regex captures the grams of filament used\n      const gramsMatch = gcode.match(/total filament used \\[g\\] = ([0-9.]+)/);\n\n      // Check if the match is found and has the expected group\n      if (gramsMatch) {\n        // Convert the grams to a floating-point number\n        const grams = parseFloat(gramsMatch[1]);\n\n        // Return the total grams of filament used\n        return grams;\n      } else {\n        // Return null or some default value if the grams cannot be parsed\n        console.warn('Could not parse total grams of filament used from G-code');\n        return null;\n      }\n    },\n    parseExtrusionWidth(gcode) {\n      // This regex captures the extrusion width, accommodating for variations in format\n      const extrusionMatch = gcode.match(/; extrusion_width = (\\d+(\\.\\d+)?)/);\n\n      // Check if the match is found and has the expected group\n      if (extrusionMatch) {\n        // Convert the width to a floating-point number\n        const extrusion = parseFloat(extrusionMatch[1]);\n\n        // Return the extracted extrusion width\n        return extrusion;\n      } else {\n        // Return null or some default value if the width cannot be parsed\n        console.warn('Could not parse extrusion width used from G-code');\n        return null;\n      }\n    },\n    parseFilamentCost(gcodeText) {\n      const match = gcodeText.match(/; total filament cost = (\\d+(\\.\\d+)?)/); // Regex to match cost line and capture cost value\n      if (match && match[1]) {\n        // If match is found and the captured group is not undefined\n        return parseFloat(match[1]); // Convert the captured group (cost value) to a float and return it\n      } else {\n        console.error('Filament cost not found in gcode text.'); // Log an error if the cost line isn't found\n        return 0; // Return a default value (like 0) if no match is found\n      }\n    },\n\n    convertSecondsToTimeFormat(seconds) {\n      const days = Math.floor(seconds / 86400);\n      const hrs = Math.floor(seconds % 86400 / 3600);\n      const mins = Math.floor(seconds % 3600 / 60);\n      const secs = seconds % 60;\n      const timeString = [days, hrs, mins, secs].map(v => (v < 10 ? '0' : '') + v).join(':');\n      return timeString;\n    },\n    convertSecondsToDayHourMinuteFormat(seconds) {\n      const days = Math.floor(seconds / 86400);\n      seconds -= days * 86400;\n      const hours = Math.floor(seconds / 3600);\n      seconds -= hours * 3600;\n      const minutes = Math.floor(seconds / 60);\n\n      // Construct the formatted string\n      let timeString = '';\n      if (days > 0) timeString += `${days}d`;\n      if (hours > 0) timeString += `${hours}h`;\n      if (minutes > 0) timeString += `${minutes}m`;\n\n      // Handle the case where the input seconds are zero or the calculations result in zero\n      if (!timeString) timeString = '0m';\n      return timeString;\n    },\n    createNewFilename(filename, copies, totalTime) {\n      const parts = filename.split('_');\n      if (parts.length >= 3) {\n        const firstPart = parts[0];\n        const middlePart = parts.slice(1, -1).join('_');\n        return firstPart + \"-x\" + copies + \"_\" + middlePart + \"_\" + this.convertSecondsToDayHourMinuteFormat(copies * totalTime) + \".gcode\";\n      }\n      console.warn('Not enough underscores found in filename');\n      return [filename];\n    },\n    findBounds(gcode) {\n      let recording = false;\n      let minX = Infinity;\n      let maxX = -Infinity;\n      let minY = Infinity;\n      let maxY = -Infinity;\n      const lines = gcode.split('\\n');\n      for (const line of lines) {\n        if (line.includes(';TYPE:External perimeter')) {\n          recording = true;\n          continue;\n        }\n        if (recording && line.includes(';WIPE_START')) {\n          recording = false;\n        }\n        if (recording && line.startsWith('G1')) {\n          const coords = this.extractXYCoords(line);\n          if (coords) {\n            const {\n              x,\n              y\n            } = coords;\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n          }\n        }\n      }\n      return {\n        minX: minX === Infinity ? null : minX,\n        maxX: maxX === -Infinity ? null : maxX,\n        minY: minY === Infinity ? null : minY,\n        maxY: maxY === -Infinity ? null : maxY\n      };\n    },\n    extractXYCoords(line) {\n      const xMatch = line.match(/X([-\\d.]+)/);\n      const yMatch = line.match(/Y([-\\d.]+)/);\n      if (!xMatch || !yMatch) return null;\n      return {\n        x: parseFloat(xMatch[1]),\n        y: parseFloat(yMatch[1])\n      };\n    }\n  },\n  computed: {\n    totalPrintTimeSeconds() {\n      return this.gcodeData.printTimeSeconds * this.form.copies;\n    },\n    totalPrintTime() {\n      return this.convertSecondsToTimeFormat(this.totalPrintTimeSeconds);\n    },\n    totalGramsOfFilament() {\n      return (this.parseGramsOfFilament(this.gcodeText) * this.form.copies).toFixed(2);\n    },\n    totalCostOfFilament() {\n      return \"$\" + (this.parseFilamentCost(this.gcodeText) * this.form.copies).toFixed(2);\n    }\n  },\n  watch: {\n    totalPrintTime(newValue) {\n      this.gcodeData.totalPrintTime = newValue;\n    },\n    totalGramsOfFilament(newValue) {\n      this.gcodeData.totalGramsOfFilament = newValue;\n    },\n    totalCostOfFilament(newValue) {\n      this.gcodeData.totalCostOfFilament = newValue;\n    }\n  }\n};","map":{"version":3,"names":["data","gcodeText","thumbnailSrc","fileName","newFileName","form","copies","ejectionSide","pushHeight","ejectionOffset","bedLength","bedWidth","gcodeData","height","minX","maxX","minY","maxY","extrusionWidth","bounds","printTimeSeconds","totalPrintTime","totalGramsOfFilament","totalCostOfFilament","methods","browseFile","$refs","fileInput","click","replaceFile","onFileChange","e","files","target","dataTransfer","length","name","split","pop","toLowerCase","alert","createFile","onDrop","file","reader","FileReader","onload","result","extractLargestThumbnail","parseExtrusionWidth","parseZHeight","parseAndConvertTime","findBounds","readAsText","gcode","console","log","matches","match","largestThumbnail","largestResolution","forEach","resolutionMatch","width","parseInt","resolution","base64String","replace","downloadFile","blob","Blob","type","link","document","createElement","href","URL","createObjectURL","download","createNewFilename","highestZ","lines","line","startsWith","zHeight","parseFloat","timeMatch","days","hours","minutes","seconds","totalSeconds","warn","parseGramsOfFilament","gramsMatch","grams","extrusionMatch","extrusion","parseFilamentCost","error","convertSecondsToTimeFormat","Math","floor","hrs","mins","secs","timeString","map","v","join","convertSecondsToDayHourMinuteFormat","filename","totalTime","parts","firstPart","middlePart","slice","recording","Infinity","includes","coords","extractXYCoords","x","y","min","max","xMatch","yMatch","computed","totalPrintTimeSeconds","toFixed","watch","newValue"],"sources":["src/components/GCodeLooper.vue"],"sourcesContent":["<template>\n  <div>\n    <b-container>\n      <b-row>\n        <b-col>\n          <h1 class=\"font-weight-bolder\">GCode Looper</h1>\n          <img src=\"@/assets/gcode-looper-logo.svg\"/>\n          <p class=\"mt-3 mb-4\">Upload a GCode file to print and eject multiple copies of your 3D print.</p>\n          <input type=\"file\" accept=\".gcode\" @change=\"onFileChange\" ref=\"fileInput\" style=\"display:none\" />\n          <div class=\"dropzone\" @click=\"browseFile\" @drop.prevent=\"onDrop\" @dragover.prevent>\n            <span class=\"font-weight-bolder\">Drag & Drop GCode File Here</span>\n            <br />\n            <span class=\"browse-link\">Browse to Upload</span>\n          </div>\n          <p class=\"my-3\"><small>Currently only supports single object gcode files sliced with latest PrusaSlicer</small></p>\n        </b-col>\n      </b-row>\n      <hr v-if=\"gcodeText\" class=\"my-3\"/>\n      <b-row>\n        <b-col md=\"6\" class=\"mb-3 mt-2\">\n          \n          <img class=\"w-100\" :src=\"thumbnailSrc\" alt=\"Thumbnail preview\" v-if=\"thumbnailSrc\" />\n          <h3 v-if=\"fileName\" class=\"filename-display\">{{ fileName }}</h3>\n\n          <b-table-simple v-if=\"fileName\" class=\"mt-3\" responsive striped bordered small>\n          <b-tbody>\n            <!-- 3D Specifications Header -->\n            <b-tr class=\"text-center bg-info text-white table-header\"><b-td :colspan=\"2\">File Specifications</b-td></b-tr>\n            <!-- Height Row -->\n            <b-tr><b-td>Bed Position [X,Y]</b-td><b-td>{{ ((gcodeData.bounds.maxX + gcodeData.bounds.minX) / 2).toFixed(2)}}, {{ ((gcodeData.bounds.maxY + gcodeData.bounds.minY) / 2).toFixed(2)}}</b-td></b-tr>\n            <b-tr><b-td>Height</b-td><b-td>{{ (gcodeData.height).toFixed(2) }}</b-td></b-tr>\n            <b-tr><b-td>Width</b-td><b-td>{{ ((gcodeData.bounds.maxX - gcodeData.bounds.minX) + gcodeData.extrusionWidth).toFixed(2)}}</b-td></b-tr>\n            <b-tr><b-td>Length</b-td><b-td>{{ ((gcodeData.bounds.maxY - gcodeData.bounds.minY) + gcodeData.extrusionWidth).toFixed(2)}}</b-td></b-tr>\n            <b-tr><b-td>X Bounds [min,max]</b-td><b-td>{{ (gcodeData.bounds.minX - (gcodeData.extrusionWidth / 2)).toFixed(2)}}, {{ (gcodeData.bounds.maxX + (gcodeData.extrusionWidth / 2)).toFixed(2)}}</b-td></b-tr>\n            <b-tr><b-td>Y Bounds [min,max]</b-td><b-td>{{ (gcodeData.bounds.minY - (gcodeData.extrusionWidth / 2)).toFixed(2)}}, {{ (gcodeData.bounds.maxY + (gcodeData.extrusionWidth / 2)).toFixed(2)}}</b-td></b-tr>\n            \n          </b-tbody>\n        </b-table-simple>\n          \n          <div v-if=\"gcodeText\" class=\"gcode-window mt-4\">\n            <pre>{{ gcodeText }}</pre>\n          </div>\n          <small v-if=\"gcodeText\">Original GCode</small>\n        </b-col>\n        <b-col md=\"6\" class=\"mb-3\">\n          <!-- Input Form -->\n          <b-form v-if=\"gcodeText\" @submit.prevent>\n\n            <b-table-simple v-if=\"fileName\" class=\"mt-2\" responsive striped bordered small>\n              <b-tbody>\n                <!-- Estimated Totals Header -->\n                <b-tr class=\"text-center bg-info text-white table-header\"><b-td :colspan=\"2\">Estimated Totals</b-td></b-tr>\n                <b-tr v-b-tooltip.hover title=\"Days : Hours : Minutes : Seconds\"><b-td>Print Time</b-td><b-td>{{ gcodeData.totalPrintTime }}</b-td></b-tr>\n                <b-tr><b-td>Grams of Filament</b-td><b-td>{{ gcodeData.totalGramsOfFilament }}</b-td></b-tr>\n                <b-tr><b-td>Cost of Filament</b-td><b-td>{{ gcodeData.totalCostOfFilament }}</b-td></b-tr>\n              </b-tbody>\n            </b-table-simple>\n\n            <b-input-group class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"The number of copies of your 3D print.\">Copies:</b-input-group-text>\n              <b-form-input type=\"number\" v-model=\"form.copies\" min=\"1\" required></b-form-input>\n            </b-input-group>\n\n            <b-input-group class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"The side of your 3D printer you want the parts to be ejected from.\">Ejection Side:</b-input-group-text>\n              <b-form-select v-model=\"form.ejectionSide\" :options=\"['Left', 'Right', 'Front', 'Back']\" required></b-form-select>\n            </b-input-group>\n\n            <!-- Conditionally rendered input fields -->\n            <b-input-group v-if=\"form.ejectionSide === 'Back'\" class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"The length in millimeters of the bed of your 3D printer. This will be used for the ejection of each print.\">Bed Length (mm):</b-input-group-text>\n              <b-form-input type=\"number\" v-model=\"form.bedLength\" step=\"0.01\" required></b-form-input>\n            </b-input-group>\n            <b-input-group v-if=\"form.ejectionSide === 'Right'\" class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"The length in millimeters of the bed of your 3D printer. This will be used for the ejection of each print.\">Bed Width (mm):</b-input-group-text>\n              <b-form-input type=\"number\" v-model=\"form.bedWidth\" step=\"0.01\" required></b-form-input>\n            </b-input-group>\n            \n            <b-input-group class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"How far the nozzle of your 3D printer will move away from the bounds of your part when it is ejected.\">Print Head Offset (mm):</b-input-group-text>\n              <b-form-input type=\"number\" v-model=\"form.ejectionOffset\" step=\"0.01\" required></b-form-input>\n            </b-input-group>\n\n            <b-input-group class=\"mb-3\">\n              <b-input-group-text v-b-tooltip.hover title=\"How far the nozzle of your 3D printer will be raised off the print bed while the part is ejected\">Push Height (mm):</b-input-group-text>\n              <b-form-input type=\"number\" v-model=\"form.pushHeight\" step=\"0.01\" required></b-form-input>\n            </b-input-group>\n\n\n          </b-form>\n          <b-button @click=\"downloadFile\" variant=\"success\" v-if=\"gcodeText\">Download New GCode</b-button>\n        </b-col>\n        \n      </b-row>\n      <b-row class=\"my-4\">\n        <b-col>\n          <p>Finding this web app useful? Consider donating</p>\n          <a href=\"https://github.com/sponsors/CurlyTaleGames\" target=\"_blank\" class=\"btn btn-light mx-2\">\n            <img src=\"@/assets/github.svg\" alt=\"Github Sponsors\" height=\"22px\"/> GitHub Sponsors\n          </a>\n          <a href=\"https://www.paypal.com/donate/?hosted_button_id=L4GAK93DRELFW\" target=\"_blank\" class=\"btn btn-light mx-2\">\n            <img src=\"@/assets/PayPal.svg\" alt=\"PayPal\" height=\"22px\"/>\n          </a>\n        </b-col>\n      </b-row>\n    </b-container>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  data() {\n    return {\n      gcodeText: '',\n      thumbnailSrc: '',\n      fileName: '',\n      newFileName: '',\n      form: {\n        copies: 10,\n        ejectionSide: 'Front',\n        pushHeight: 20.0,\n        ejectionOffset: 40.0,\n        bedLength: null,\n        bedWidth: null\n      },\n      gcodeData:{\n        height: 0,\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0,\n        extrusionWidth: 0,\n        bounds:{\n          minX: 0,\n          maxX: 0,\n          minY: 0,\n          maxY: 0\n        },\n        printTimeSeconds: 0,\n        totalPrintTime: 0,\n        totalGramsOfFilament: 0,\n        totalCostOfFilament: 0\n      }\n    };\n  },\n  methods: {\n    browseFile() {\n      this.$refs.fileInput.click();\n    },\n    replaceFile() {\n      this.gcodeText = '';\n      this.thumbnailSrc = '';\n      this.fileName = '';\n      this.$refs.fileInput.click();\n    },\n    onFileChange(e) {\n      const files = e.target.files || e.dataTransfer.files;\n      if (!files.length) return;\n\n      // Check the file extension\n      if (files[0].name.split('.').pop().toLowerCase() !== 'gcode') {\n        alert('Invalid file type. Please upload a .gcode file.');\n        return;\n      }\n\n      this.fileName = files[0].name;\n      this.createFile(files[0]);\n    },\n    onDrop(e) {\n      // Get the dropped files\n      const files = e.dataTransfer.files;\n      if (!files.length) return;\n\n      // Check the file extension\n      if (files[0].name.split('.').pop().toLowerCase() !== 'gcode') {\n        alert('Invalid file type. Please upload a .gcode file.');\n        return;\n      }\n\n      this.onFileChange(e);\n    },\n    createFile(file) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        this.gcodeText = e.target.result;\n        this.thumbnailSrc = this.extractLargestThumbnail(this.gcodeText);\n        this.gcodeData.extrusionWidth = this.parseExtrusionWidth(this.gcodeText);\n        this.gcodeData.height = this.parseZHeight(this.gcodeText);\n        this.gcodeData.printTimeSeconds = this.parseAndConvertTime(this.gcodeText);\n        this.gcodeData.bounds = this.findBounds(this.gcodeText);\n      };\n      reader.readAsText(file);\n    },\n    extractLargestThumbnail(gcode) {\n      console.log(\"Extracting Text\");\n      console.log(gcode);\n      const matches = gcode.match(/; thumbnail begin (\\d+)x(\\d+) (\\d+)([\\s\\S+]*?); thumbnail end/g);\n      if (!matches) return '';\n\n      let largestThumbnail = '';\n      let largestResolution = 0;\n\n      matches.forEach((match) => {\n        console.log(match);\n        const resolutionMatch = match.match(/; thumbnail begin (\\d+)x(\\d+) (\\d+)/);\n        if (resolutionMatch) {\n          const width = parseInt(resolutionMatch[1], 10);\n          const height = parseInt(resolutionMatch[2], 10);\n          const resolution = width * height;\n          if (resolution > largestResolution) {\n            largestResolution = resolution;\n            // Extract the base64 thumbnail data\n            let base64String = match.replace(/^.*\\n|\\n|;\\s*/g, '');\n            base64String = base64String.replace(/=thumbnail end/g, '=');\n            largestThumbnail = 'data:image/png;base64, ' + base64String;\n          }\n        }\n      });\n      return largestThumbnail;\n    },\n    downloadFile() {\n      const blob = new Blob([this.gcodeText], { type: 'text/plain' });\n      const link = document.createElement('a');\n      link.href = URL.createObjectURL(blob);\n      link.download = this.createNewFilename(this.fileName, this.form.copies, this.gcodeData.printTimeSeconds) || 'downloaded.gcode'; // Use stored fileName for download\n      link.click();\n    },\n    parseZHeight(gcode){\n      let highestZ = 0;\n      // Split the G-code text into lines\n      const lines = gcode.split('\\n');\n      // Iterate over each line\n      lines.forEach(line => {\n        // Check if the line starts with ;Z:\n        if (line.startsWith(';Z:')) {\n          // Parse the Z height value from the line\n          const zHeight = parseFloat(line.split(';Z:')[1]);\n          // Update highestZ if this zHeight is greater than the current highestZ\n          if (zHeight > highestZ) {\n            highestZ = zHeight;\n          }\n        }\n      });\n      return highestZ;\n    },\n    parseAndConvertTime(gcode) {\n      // This regex captures optional days, hours, minutes, and seconds parts\n      const timeMatch = gcode.match(/estimated printing time.*?(?:(\\d+)d )?(?:(\\d+)h )?(\\d+)m (\\d+)s/);\n\n      // Check if the match is found and has the expected groups\n      if (timeMatch) {\n        // Convert the time to seconds\n        const days = parseInt(timeMatch[1] || 0, 10); // Default to 0 if days part is not present\n        const hours = parseInt(timeMatch[2] || 0, 10); // Default to 0 if hours part is not present\n        const minutes = parseInt(timeMatch[3], 10);\n        const seconds = parseInt(timeMatch[4], 10);\n        const totalSeconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds; // 1 day = 86400 seconds\n\n        // Return the total time in seconds\n        return totalSeconds;\n      } else {\n        // Return null or some default value if the time cannot be parsed\n        console.warn('Could not parse estimated printing time from G-code');\n        return null;\n      }\n    },\n    parseGramsOfFilament(gcode) {\n      // This regex captures the grams of filament used\n      const gramsMatch = gcode.match(/total filament used \\[g\\] = ([0-9.]+)/);\n\n      // Check if the match is found and has the expected group\n      if (gramsMatch) {\n        // Convert the grams to a floating-point number\n        const grams = parseFloat(gramsMatch[1]);\n\n        // Return the total grams of filament used\n        return grams;\n      } else {\n        // Return null or some default value if the grams cannot be parsed\n        console.warn('Could not parse total grams of filament used from G-code');\n        return null;\n      }\n    },\n    parseExtrusionWidth(gcode) {\n      // This regex captures the extrusion width, accommodating for variations in format\n      const extrusionMatch = gcode.match(/; extrusion_width = (\\d+(\\.\\d+)?)/);\n\n      // Check if the match is found and has the expected group\n      if (extrusionMatch) {\n        // Convert the width to a floating-point number\n        const extrusion = parseFloat(extrusionMatch[1]);\n\n        // Return the extracted extrusion width\n        return extrusion;\n      } else {\n        // Return null or some default value if the width cannot be parsed\n        console.warn('Could not parse extrusion width used from G-code');\n        return null;\n      }\n    },\n    parseFilamentCost(gcodeText) {\n      const match = gcodeText.match(/; total filament cost = (\\d+(\\.\\d+)?)/); // Regex to match cost line and capture cost value\n      if (match && match[1]) { // If match is found and the captured group is not undefined\n        return parseFloat(match[1]); // Convert the captured group (cost value) to a float and return it\n      } else {\n        console.error('Filament cost not found in gcode text.'); // Log an error if the cost line isn't found\n        return 0; // Return a default value (like 0) if no match is found\n      }\n    },\n    convertSecondsToTimeFormat(seconds) {\n      const days = Math.floor(seconds / 86400);\n      const hrs = Math.floor((seconds % 86400) / 3600);\n      const mins = Math.floor((seconds % 3600) / 60);\n      const secs = seconds % 60;\n\n      const timeString = [days, hrs, mins, secs]\n        .map(v => (v < 10 ? '0' : '') + v)\n        .join(':');\n\n      return timeString;\n    },\n    convertSecondsToDayHourMinuteFormat(seconds) {\n      const days = Math.floor(seconds / 86400);\n      seconds -= days * 86400;\n\n      const hours = Math.floor(seconds / 3600);\n      seconds -= hours * 3600;\n\n      const minutes = Math.floor(seconds / 60);\n\n      // Construct the formatted string\n      let timeString = '';\n      if (days > 0) timeString += `${days}d`;\n      if (hours > 0) timeString += `${hours}h`;\n      if (minutes > 0) timeString += `${minutes}m`;\n\n      // Handle the case where the input seconds are zero or the calculations result in zero\n      if (!timeString) timeString = '0m';\n\n      return timeString;\n    },\n    createNewFilename(filename, copies, totalTime) {\n      const parts = filename.split('_');\n      if (parts.length >= 3) {\n        const firstPart = parts[0];\n        const middlePart = parts.slice(1, -1).join('_');\n        return firstPart + \"-x\" + copies + \"_\" + middlePart + \"_\" + this.convertSecondsToDayHourMinuteFormat(copies * totalTime) + \".gcode\";\n      }\n      console.warn('Not enough underscores found in filename');\n      return [filename];\n    },\n    findBounds(gcode) {\n      let recording = false;\n      let minX = Infinity;\n      let maxX = -Infinity;\n      let minY = Infinity;\n      let maxY = -Infinity;\n\n      const lines = gcode.split('\\n');\n      for (const line of lines) {\n        if (line.includes(';TYPE:External perimeter')) {\n          recording = true;\n          continue;\n        }\n\n        if (recording && line.includes(';WIPE_START')) {\n          recording = false;\n        }\n\n        if (recording && line.startsWith('G1')) {\n          const coords = this.extractXYCoords(line);\n          if (coords) {\n            const { x, y } = coords;\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n          }\n        }\n      }\n      \n      return {\n        minX: minX === Infinity ? null : minX,\n        maxX: maxX === -Infinity ? null : maxX,\n        minY: minY === Infinity ? null : minY,\n        maxY: maxY === -Infinity ? null : maxY,\n      };\n    },\n    extractXYCoords(line) {\n      const xMatch = line.match(/X([-\\d.]+)/);\n      const yMatch = line.match(/Y([-\\d.]+)/);\n      if (!xMatch || !yMatch) return null;\n      return {\n        x: parseFloat(xMatch[1]),\n        y: parseFloat(yMatch[1]),\n      };\n    }\n  },\n  computed: {\n    totalPrintTimeSeconds() {\n      return this.gcodeData.printTimeSeconds * this.form.copies;\n    },\n    totalPrintTime() {\n      return this.convertSecondsToTimeFormat(this.totalPrintTimeSeconds);\n    },\n    totalGramsOfFilament() {\n      return (this.parseGramsOfFilament(this.gcodeText) * this.form.copies).toFixed(2);\n    },\n    totalCostOfFilament() {\n      return \"$\" + (this.parseFilamentCost(this.gcodeText) * this.form.copies).toFixed(2);\n    },\n  },\n  watch: {\n    totalPrintTime(newValue) {\n      this.gcodeData.totalPrintTime = newValue;\n    },\n    totalGramsOfFilament(newValue) {\n      this.gcodeData.totalGramsOfFilament = newValue;\n    },\n    totalCostOfFilament(newValue) {\n      this.gcodeData.totalCostOfFilament = newValue;\n    },\n  },\n};\n</script>\n\n<style>\n.dropzone {\n  border: 2px dashed #6aa961;\n  padding: 20px;\n  cursor: pointer;\n  text-align: center;\n  background-color: rgba(106, 169, 97, 12%);\n}\n\n.dropzone:hover {\n  background-color: rgba(106, 169, 97, 25%);\n}\n\n.dropzone span{\n  font-weight: 700 !important;\n}\n\n.browse-link {\n  display: inline-block;\n  margin-top: 10px;\n  color: #6aa961;\n  cursor: pointer;\n  text-decoration: underline;\n}\n\n.gcode-window {\n  border: 1px solid #ccc;\n  padding: 10px;\n  height: 200px;\n  overflow-y: scroll;\n}\n\npre{\n  text-align: left;\n}\n\n.filename-display {\n  margin: 10px 0;\n  font-weight: bold;\n  font-size: calc(0.5vw + 0.5vh + .5vmin)\n}\n\nh1{\n  font-weight: 700 !important;\n}\n\nsmall{\n  opacity: 50%;\n  margin: 30px 0;\n}\n\n/* fix for missing tooltip arrow */\n.tooltip .arrow {\n    position: absolute;\n    display: block;\n    width: 0.8rem;\n    height: 0.4rem;\n}\n\n.bs-tooltip-top .arrow {\n    bottom: -6px;\n}\n\n.tooltip .arrow::before {\n    content: \"\";\n    position: absolute;\n    border-color: transparent;\n    border-style: solid;\n}\n\n.bs-tooltip-top .arrow::before {\n    border-width: 0.4rem 0.4rem 0;\n    border-top-color: #000000;\n} \n\n.table-header{\n  font-weight: 700 !important;\n}\n\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}